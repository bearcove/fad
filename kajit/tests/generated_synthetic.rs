// @generated by xtask generate-synthetic. Do not edit manually.
use facet::Facet;

use serde::{Serialize, Deserialize};
#[derive(Debug, PartialEq, Serialize, Deserialize, Facet)]
struct Friend {
    age: u32,
    name: String,
}
#[derive(Debug, PartialEq, Serialize, Deserialize, Facet)]
struct Address {
    city: String,
    zip: u32,
}
#[derive(Debug, PartialEq, Serialize, Deserialize, Facet)]
struct Person {
    name: String,
    age: u32,
    address: Address,
}
#[derive(Debug, PartialEq, Serialize, Deserialize, Facet)]
struct Inner {
    x: u32,
}
#[derive(Debug, PartialEq, Serialize, Deserialize, Facet)]
struct Middle {
    inner: Inner,
    y: u32,
}
#[derive(Debug, PartialEq, Serialize, Deserialize, Facet)]
struct Outer {
    middle: Middle,
    z: u32,
}
#[derive(Debug, PartialEq, Serialize, Deserialize, Facet)]
struct AllIntegers {
    a_u8: u8,
    a_u16: u16,
    a_u32: u32,
    a_u64: u64,
    a_i8: i8,
    a_i16: i16,
    a_i32: i32,
    a_i64: i64,
}
#[derive(Debug, PartialEq, Serialize, Deserialize, Facet)]
struct BoolField {
    value: bool,
}
#[derive(Debug, PartialEq, Serialize, Deserialize, Facet)]
struct ScalarVec {
    values: Vec<u32>,
}
type Pair = (u32, String);

fn assert_json_case<T>(value: T)
where
    for<'input> T: Facet<'input> + serde::Serialize + serde::de::DeserializeOwned + PartialEq + std::fmt::Debug,
{
    let encoded = serde_json::to_string(&value).unwrap();
    let expected: T = serde_json::from_str(&encoded).unwrap();
    let decoder = kajit::compile_decoder_legacy(T::SHAPE, &kajit::json::KajitJson);
    let got: T = kajit::from_str(&decoder, &encoded).unwrap();
    assert_eq!(got, expected);
}

fn assert_postcard_case<T>(value: T, with_ir: bool)
where
    for<'input> T: Facet<'input> + serde::Serialize + serde::de::DeserializeOwned + PartialEq + std::fmt::Debug,
{
    let encoded = postcard::to_allocvec(&value).unwrap();
    let expected: T = postcard::from_bytes(&encoded).unwrap();
    let legacy = kajit::compile_decoder_legacy(T::SHAPE, &kajit::postcard::KajitPostcard);
    let legacy_out: T = kajit::deserialize(&legacy, &encoded).unwrap();
    assert_eq!(legacy_out, expected);
    if with_ir {
        let ir = kajit::compile_decoder_via_ir(T::SHAPE, &kajit::postcard::KajitPostcard);
        let ir_out: T = kajit::deserialize(&ir, &encoded).unwrap();
        assert_eq!(ir_out, expected);
    }
}

fn assert_ir_ra_snapshots(
    case: &str,
    format_label: &str,
    shape: &'static facet::Shape,
    decoder: &dyn kajit::format::IrDecoder,
) {
    let (ir_text, ra_text) = kajit::debug_ir_and_ra_mir_text(shape, decoder);
    insta::assert_snapshot!(
        format!(
            "generated_rvsdg_{}_{}_{}",
            format_label,
            case,
            std::env::consts::ARCH
        ),
        ir_text
    );
    insta::assert_snapshot!(
        format!(
            "generated_ra_mir_{}_{}_{}",
            format_label,
            case,
            std::env::consts::ARCH
        ),
        ra_text
    );
}

#[test]
fn generated_json_flat_struct() {
    let value: Friend = Friend { age: 42, name: "Alice".into() };
    assert_json_case(value);
}

#[test]
fn generated_postcard_flat_struct() {
    let value: Friend = Friend { age: 42, name: "Alice".into() };
    assert_postcard_case(value, true);
    assert_ir_ra_snapshots("flat_struct", "postcard", <Friend>::SHAPE, &kajit::postcard::KajitPostcard);
}

#[test]
fn generated_json_nested_struct() {
    let value: Person = Person { name: "Alice".into(), age: 30, address: Address { city: "Portland".into(), zip: 97201 } };
    assert_json_case(value);
}

#[test]
fn generated_postcard_nested_struct() {
    let value: Person = Person { name: "Alice".into(), age: 30, address: Address { city: "Portland".into(), zip: 97201 } };
    assert_postcard_case(value, true);
    assert_ir_ra_snapshots("nested_struct", "postcard", <Person>::SHAPE, &kajit::postcard::KajitPostcard);
}

#[test]
fn generated_json_deep_struct() {
    let value: Outer = Outer { middle: Middle { inner: Inner { x: 1 }, y: 2 }, z: 3 };
    assert_json_case(value);
}

#[test]
fn generated_postcard_deep_struct() {
    let value: Outer = Outer { middle: Middle { inner: Inner { x: 1 }, y: 2 }, z: 3 };
    assert_postcard_case(value, true);
    assert_ir_ra_snapshots("deep_struct", "postcard", <Outer>::SHAPE, &kajit::postcard::KajitPostcard);
}

#[test]
fn generated_json_all_integers() {
    let value: AllIntegers = AllIntegers { a_u8: 255, a_u16: 65535, a_u32: 1_000_000, a_u64: 1_000_000_000_000, a_i8: -128, a_i16: -32768, a_i32: -1_000_000, a_i64: -1_000_000_000_000 };
    assert_json_case(value);
}

#[test]
fn generated_postcard_all_integers() {
    let value: AllIntegers = AllIntegers { a_u8: 255, a_u16: 65535, a_u32: 1_000_000, a_u64: 1_000_000_000_000, a_i8: -128, a_i16: -32768, a_i32: -1_000_000, a_i64: -1_000_000_000_000 };
    assert_postcard_case(value, true);
    assert_ir_ra_snapshots("all_integers", "postcard", <AllIntegers>::SHAPE, &kajit::postcard::KajitPostcard);
}

#[test]
fn generated_json_bool_field() {
    let value: BoolField = BoolField { value: true };
    assert_json_case(value);
}

#[test]
fn generated_postcard_bool_field() {
    let value: BoolField = BoolField { value: true };
    assert_postcard_case(value, true);
    assert_ir_ra_snapshots("bool_field", "postcard", <BoolField>::SHAPE, &kajit::postcard::KajitPostcard);
}

#[test]
fn generated_json_tuple_pair() {
    let value: Pair = (42u32, "Alice".to_string());
    assert_json_case(value);
}

#[test]
fn generated_postcard_tuple_pair() {
    let value: Pair = (42u32, "Alice".to_string());
    assert_postcard_case(value, true);
    assert_ir_ra_snapshots("tuple_pair", "postcard", <Pair>::SHAPE, &kajit::postcard::KajitPostcard);
}

#[test]
fn generated_json_vec_scalar_small() {
    let value: ScalarVec = ScalarVec { values: (0..16).map(|i| i as u32).collect() };
    assert_json_case(value);
}

#[test]
fn generated_postcard_vec_scalar_small() {
    let value: ScalarVec = ScalarVec { values: (0..16).map(|i| i as u32).collect() };
    assert_postcard_case(value, true);
    assert_ir_ra_snapshots("vec_scalar_small", "postcard", <ScalarVec>::SHAPE, &kajit::postcard::KajitPostcard);
}

#[test]
fn generated_json_vec_scalar_large() {
    let value: ScalarVec = ScalarVec { values: (0..2048).map(|i| i as u32).collect() };
    assert_json_case(value);
}

#[test]
fn generated_postcard_vec_scalar_large() {
    let value: ScalarVec = ScalarVec { values: (0..2048).map(|i| i as u32).collect() };
    assert_postcard_case(value, true);
    assert_ir_ra_snapshots("vec_scalar_large", "postcard", <ScalarVec>::SHAPE, &kajit::postcard::KajitPostcard);
}

