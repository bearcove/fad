// @generated by xtask generate-ir-postreg-corpus. Do not edit manually.
use facet::Facet;

fn parse_case(ir: &str) -> kajit::ir::IrFunc {
    let registry = kajit::ir::IntrinsicRegistry::empty();
    kajit::ir_parse::parse_ir(ir, <u8 as Facet>::SHAPE, &registry)
        .expect("text IR should parse")
}

fn run_exec(ir: &str, input: &[u8], with_passes: bool) -> u8 {
    let mut func = parse_case(ir);
    if with_passes {
        kajit::ir_passes::run_default_passes(&mut func);
    }
    let linear = kajit::linearize::linearize(&mut func);
    let dec = kajit::compile_decoder_linear_ir(&linear, false);
    kajit::deserialize::<u8>(&dec, input).expect("decoder should execute")
}

fn postreg_artifacts(ir: &str) -> (String, String, usize) {
    let mut func = parse_case(ir);
    kajit::ir_passes::run_default_passes(&mut func);
    let linear = kajit::linearize::linearize(&mut func);
    let linear_text = format!("{linear}");
    let ra = kajit::regalloc_mir::lower_linear_ir(&linear);
    let ra_text = format!("{ra}");
    let alloc = kajit::regalloc_engine::allocate_program(&ra)
        .expect("regalloc should allocate post-reg corpus case");
    let edits: usize = alloc.functions.iter().map(|f| f.edits.len()).sum();
    (linear_text, ra_text, edits)
}

#[test]
fn ir_postreg_snapshot_cmpne_gamma_branch() {
    let (linear, ra, edits) = postreg_artifacts(r#"
lambda @0 (shape: "u8") {
  region {
    args: [%cs, %os]
    n0 = BoundsCheck(1) [%cs:arg] -> [%cs]
    n1 = ReadBytes(1) [%cs:n0] -> [v0, %cs]
    n2 = Const(0x0) [] -> [v1]
    n3 = CmpNe [v0, v1] -> [v2]
    n4 = gamma [
      pred: v2
      in0: %cs:n1
      in1: %os:arg
    ] {
      branch 0:
        region {
          args: [%cs, %os]
          n5 = Const(0x3) [] -> [v3]
          results: [v3, %cs:arg, %os:arg]
        }
      branch 1:
        region {
          args: [%cs, %os]
          n6 = Const(0x7) [] -> [v4]
          results: [v4, %cs:arg, %os:arg]
        }
    } -> [v5, %cs, %os]
    n7 = WriteToField(offset=0, W1) [v5, %os:n4] -> [%os]
    results: [%cs:n4, %os:n7]
  }
}
"#);
    insta::assert_snapshot!("generated_ir_postreg_linear_cmpne_gamma_branch", linear);
    insta::assert_snapshot!("generated_ir_postreg_ra_cmpne_gamma_branch", ra);
    insta::assert_snapshot!("generated_ir_postreg_edits_cmpne_gamma_branch", format!("{edits}"));
}

#[test]
fn ir_postreg_asserts_cmpne_gamma_branch() {
    let (linear, _ra, edits) = postreg_artifacts(r#"
lambda @0 (shape: "u8") {
  region {
    args: [%cs, %os]
    n0 = BoundsCheck(1) [%cs:arg] -> [%cs]
    n1 = ReadBytes(1) [%cs:n0] -> [v0, %cs]
    n2 = Const(0x0) [] -> [v1]
    n3 = CmpNe [v0, v1] -> [v2]
    n4 = gamma [
      pred: v2
      in0: %cs:n1
      in1: %os:arg
    ] {
      branch 0:
        region {
          args: [%cs, %os]
          n5 = Const(0x3) [] -> [v3]
          results: [v3, %cs:arg, %os:arg]
        }
      branch 1:
        region {
          args: [%cs, %os]
          n6 = Const(0x7) [] -> [v4]
          results: [v4, %cs:arg, %os:arg]
        }
    } -> [v5, %cs, %os]
    n7 = WriteToField(offset=0, W1) [v5, %os:n4] -> [%os]
    results: [%cs:n4, %os:n7]
  }
}
"#);
    assert!(edits <= 64, "expected edit budget <= 64, got {edits}");
    assert!(linear.contains(r#"CmpNe"#), "expected linear artifact to contain: {}", r#"CmpNe"#);
    assert!(linear.contains(r#"br_zero"#), "expected linear artifact to contain: {}", r#"br_zero"#);
}

#[test]
fn ir_postreg_exec_cmpne_gamma_branch() {
    let before = run_exec(r#"
lambda @0 (shape: "u8") {
  region {
    args: [%cs, %os]
    n0 = BoundsCheck(1) [%cs:arg] -> [%cs]
    n1 = ReadBytes(1) [%cs:n0] -> [v0, %cs]
    n2 = Const(0x0) [] -> [v1]
    n3 = CmpNe [v0, v1] -> [v2]
    n4 = gamma [
      pred: v2
      in0: %cs:n1
      in1: %os:arg
    ] {
      branch 0:
        region {
          args: [%cs, %os]
          n5 = Const(0x3) [] -> [v3]
          results: [v3, %cs:arg, %os:arg]
        }
      branch 1:
        region {
          args: [%cs, %os]
          n6 = Const(0x7) [] -> [v4]
          results: [v4, %cs:arg, %os:arg]
        }
    } -> [v5, %cs, %os]
    n7 = WriteToField(offset=0, W1) [v5, %os:n4] -> [%os]
    results: [%cs:n4, %os:n7]
  }
}
"#, &[1], false);
    let after = run_exec(r#"
lambda @0 (shape: "u8") {
  region {
    args: [%cs, %os]
    n0 = BoundsCheck(1) [%cs:arg] -> [%cs]
    n1 = ReadBytes(1) [%cs:n0] -> [v0, %cs]
    n2 = Const(0x0) [] -> [v1]
    n3 = CmpNe [v0, v1] -> [v2]
    n4 = gamma [
      pred: v2
      in0: %cs:n1
      in1: %os:arg
    ] {
      branch 0:
        region {
          args: [%cs, %os]
          n5 = Const(0x3) [] -> [v3]
          results: [v3, %cs:arg, %os:arg]
        }
      branch 1:
        region {
          args: [%cs, %os]
          n6 = Const(0x7) [] -> [v4]
          results: [v4, %cs:arg, %os:arg]
        }
    } -> [v5, %cs, %os]
    n7 = WriteToField(offset=0, W1) [v5, %os:n4] -> [%os]
    results: [%cs:n4, %os:n7]
  }
}
"#, &[1], true);
    assert_eq!(after, 7u8, "optimized output mismatch against expected");
    assert_eq!(after, before, "optimized and baseline outputs diverged");
}

#[test]
fn ir_postreg_snapshot_and_cmpne_gamma_branch() {
    let (linear, ra, edits) = postreg_artifacts(r#"
lambda @0 (shape: "u8") {
  region {
    args: [%cs, %os]
    n0 = BoundsCheck(2) [%cs:arg] -> [%cs]
    n1 = ReadBytes(1) [%cs:n0] -> [v0, %cs]
    n2 = ReadBytes(1) [%cs:n1] -> [v1, %cs]
    n3 = Const(0x0) [] -> [v2]
    n4 = CmpNe [v0, v2] -> [v3]
    n5 = CmpNe [v1, v2] -> [v4]
    n6 = And [v3, v4] -> [v5]
    n7 = gamma [
      pred: v5
      in0: %cs:n2
      in1: %os:arg
    ] {
      branch 0:
        region {
          args: [%cs, %os]
          n8 = Const(0x4) [] -> [v6]
          results: [v6, %cs:arg, %os:arg]
        }
      branch 1:
        region {
          args: [%cs, %os]
          n9 = Const(0x9) [] -> [v7]
          results: [v7, %cs:arg, %os:arg]
        }
    } -> [v8, %cs, %os]
    n10 = WriteToField(offset=0, W1) [v8, %os:n7] -> [%os]
    results: [%cs:n7, %os:n10]
  }
}
"#);
    insta::assert_snapshot!("generated_ir_postreg_linear_and_cmpne_gamma_branch", linear);
    insta::assert_snapshot!("generated_ir_postreg_ra_and_cmpne_gamma_branch", ra);
    insta::assert_snapshot!("generated_ir_postreg_edits_and_cmpne_gamma_branch", format!("{edits}"));
}

#[test]
fn ir_postreg_asserts_and_cmpne_gamma_branch() {
    let (linear, _ra, edits) = postreg_artifacts(r#"
lambda @0 (shape: "u8") {
  region {
    args: [%cs, %os]
    n0 = BoundsCheck(2) [%cs:arg] -> [%cs]
    n1 = ReadBytes(1) [%cs:n0] -> [v0, %cs]
    n2 = ReadBytes(1) [%cs:n1] -> [v1, %cs]
    n3 = Const(0x0) [] -> [v2]
    n4 = CmpNe [v0, v2] -> [v3]
    n5 = CmpNe [v1, v2] -> [v4]
    n6 = And [v3, v4] -> [v5]
    n7 = gamma [
      pred: v5
      in0: %cs:n2
      in1: %os:arg
    ] {
      branch 0:
        region {
          args: [%cs, %os]
          n8 = Const(0x4) [] -> [v6]
          results: [v6, %cs:arg, %os:arg]
        }
      branch 1:
        region {
          args: [%cs, %os]
          n9 = Const(0x9) [] -> [v7]
          results: [v7, %cs:arg, %os:arg]
        }
    } -> [v8, %cs, %os]
    n10 = WriteToField(offset=0, W1) [v8, %os:n7] -> [%os]
    results: [%cs:n7, %os:n10]
  }
}
"#);
    assert!(edits <= 96, "expected edit budget <= 96, got {edits}");
    assert!(linear.contains(r#"And"#), "expected linear artifact to contain: {}", r#"And"#);
    assert!(linear.contains(r#"CmpNe"#), "expected linear artifact to contain: {}", r#"CmpNe"#);
    assert!(linear.contains(r#"br_zero"#), "expected linear artifact to contain: {}", r#"br_zero"#);
}

#[test]
fn ir_postreg_exec_and_cmpne_gamma_branch() {
    let before = run_exec(r#"
lambda @0 (shape: "u8") {
  region {
    args: [%cs, %os]
    n0 = BoundsCheck(2) [%cs:arg] -> [%cs]
    n1 = ReadBytes(1) [%cs:n0] -> [v0, %cs]
    n2 = ReadBytes(1) [%cs:n1] -> [v1, %cs]
    n3 = Const(0x0) [] -> [v2]
    n4 = CmpNe [v0, v2] -> [v3]
    n5 = CmpNe [v1, v2] -> [v4]
    n6 = And [v3, v4] -> [v5]
    n7 = gamma [
      pred: v5
      in0: %cs:n2
      in1: %os:arg
    ] {
      branch 0:
        region {
          args: [%cs, %os]
          n8 = Const(0x4) [] -> [v6]
          results: [v6, %cs:arg, %os:arg]
        }
      branch 1:
        region {
          args: [%cs, %os]
          n9 = Const(0x9) [] -> [v7]
          results: [v7, %cs:arg, %os:arg]
        }
    } -> [v8, %cs, %os]
    n10 = WriteToField(offset=0, W1) [v8, %os:n7] -> [%os]
    results: [%cs:n7, %os:n10]
  }
}
"#, &[1, 1], false);
    let after = run_exec(r#"
lambda @0 (shape: "u8") {
  region {
    args: [%cs, %os]
    n0 = BoundsCheck(2) [%cs:arg] -> [%cs]
    n1 = ReadBytes(1) [%cs:n0] -> [v0, %cs]
    n2 = ReadBytes(1) [%cs:n1] -> [v1, %cs]
    n3 = Const(0x0) [] -> [v2]
    n4 = CmpNe [v0, v2] -> [v3]
    n5 = CmpNe [v1, v2] -> [v4]
    n6 = And [v3, v4] -> [v5]
    n7 = gamma [
      pred: v5
      in0: %cs:n2
      in1: %os:arg
    ] {
      branch 0:
        region {
          args: [%cs, %os]
          n8 = Const(0x4) [] -> [v6]
          results: [v6, %cs:arg, %os:arg]
        }
      branch 1:
        region {
          args: [%cs, %os]
          n9 = Const(0x9) [] -> [v7]
          results: [v7, %cs:arg, %os:arg]
        }
    } -> [v8, %cs, %os]
    n10 = WriteToField(offset=0, W1) [v8, %os:n7] -> [%os]
    results: [%cs:n7, %os:n10]
  }
}
"#, &[1, 1], true);
    assert_eq!(after, 9u8, "optimized output mismatch against expected");
    assert_eq!(after, before, "optimized and baseline outputs diverged");
}

#[test]
fn ir_postreg_snapshot_theta_then_gamma_edit_budget() {
    let (linear, ra, edits) = postreg_artifacts(r#"
lambda @0 (shape: "u8") {
  region {
    args: [%cs, %os]
    n0 = Const(0x3) [] -> [v0]
    n1 = Const(0x1) [] -> [v1]
    n2 = theta [v0, v1, %cs:arg, %os:arg] {
      region {
        args: [arg0, arg1, %cs, %os]
        n3 = Sub [arg0, arg1] -> [v2]
        results: [v2, v2, arg1, %cs:arg, %os:arg]
      }
    } -> [v3, v4, %cs, %os]
    n4 = gamma [
      pred: v3
      in0: %cs:n2
      in1: %os:n2
    ] {
      branch 0:
        region {
          args: [%cs, %os]
          n5 = Const(0xb) [] -> [v5]
          results: [v5, %cs:arg, %os:arg]
        }
      branch 1:
        region {
          args: [%cs, %os]
          n6 = Const(0x16) [] -> [v6]
          results: [v6, %cs:arg, %os:arg]
        }
    } -> [v7, %cs, %os]
    n8 = WriteToField(offset=0, W1) [v7, %os:n4] -> [%os]
    results: [%cs:n4, %os:n8]
  }
}
"#);
    insta::assert_snapshot!("generated_ir_postreg_linear_theta_then_gamma_edit_budget", linear);
    insta::assert_snapshot!("generated_ir_postreg_ra_theta_then_gamma_edit_budget", ra);
    insta::assert_snapshot!("generated_ir_postreg_edits_theta_then_gamma_edit_budget", format!("{edits}"));
}

#[test]
fn ir_postreg_asserts_theta_then_gamma_edit_budget() {
    let (linear, _ra, edits) = postreg_artifacts(r#"
lambda @0 (shape: "u8") {
  region {
    args: [%cs, %os]
    n0 = Const(0x3) [] -> [v0]
    n1 = Const(0x1) [] -> [v1]
    n2 = theta [v0, v1, %cs:arg, %os:arg] {
      region {
        args: [arg0, arg1, %cs, %os]
        n3 = Sub [arg0, arg1] -> [v2]
        results: [v2, v2, arg1, %cs:arg, %os:arg]
      }
    } -> [v3, v4, %cs, %os]
    n4 = gamma [
      pred: v3
      in0: %cs:n2
      in1: %os:n2
    ] {
      branch 0:
        region {
          args: [%cs, %os]
          n5 = Const(0xb) [] -> [v5]
          results: [v5, %cs:arg, %os:arg]
        }
      branch 1:
        region {
          args: [%cs, %os]
          n6 = Const(0x16) [] -> [v6]
          results: [v6, %cs:arg, %os:arg]
        }
    } -> [v7, %cs, %os]
    n8 = WriteToField(offset=0, W1) [v7, %os:n4] -> [%os]
    results: [%cs:n4, %os:n8]
  }
}
"#);
    assert!(edits <= 128, "expected edit budget <= 128, got {edits}");
    assert!(linear.contains(r#"br_if"#), "expected linear artifact to contain: {}", r#"br_if"#);
    assert!(linear.contains(r#"br_zero"#), "expected linear artifact to contain: {}", r#"br_zero"#);
}

#[test]
fn ir_postreg_exec_theta_then_gamma_edit_budget() {
    let before = run_exec(r#"
lambda @0 (shape: "u8") {
  region {
    args: [%cs, %os]
    n0 = Const(0x3) [] -> [v0]
    n1 = Const(0x1) [] -> [v1]
    n2 = theta [v0, v1, %cs:arg, %os:arg] {
      region {
        args: [arg0, arg1, %cs, %os]
        n3 = Sub [arg0, arg1] -> [v2]
        results: [v2, v2, arg1, %cs:arg, %os:arg]
      }
    } -> [v3, v4, %cs, %os]
    n4 = gamma [
      pred: v3
      in0: %cs:n2
      in1: %os:n2
    ] {
      branch 0:
        region {
          args: [%cs, %os]
          n5 = Const(0xb) [] -> [v5]
          results: [v5, %cs:arg, %os:arg]
        }
      branch 1:
        region {
          args: [%cs, %os]
          n6 = Const(0x16) [] -> [v6]
          results: [v6, %cs:arg, %os:arg]
        }
    } -> [v7, %cs, %os]
    n8 = WriteToField(offset=0, W1) [v7, %os:n4] -> [%os]
    results: [%cs:n4, %os:n8]
  }
}
"#, &[], false);
    let after = run_exec(r#"
lambda @0 (shape: "u8") {
  region {
    args: [%cs, %os]
    n0 = Const(0x3) [] -> [v0]
    n1 = Const(0x1) [] -> [v1]
    n2 = theta [v0, v1, %cs:arg, %os:arg] {
      region {
        args: [arg0, arg1, %cs, %os]
        n3 = Sub [arg0, arg1] -> [v2]
        results: [v2, v2, arg1, %cs:arg, %os:arg]
      }
    } -> [v3, v4, %cs, %os]
    n4 = gamma [
      pred: v3
      in0: %cs:n2
      in1: %os:n2
    ] {
      branch 0:
        region {
          args: [%cs, %os]
          n5 = Const(0xb) [] -> [v5]
          results: [v5, %cs:arg, %os:arg]
        }
      branch 1:
        region {
          args: [%cs, %os]
          n6 = Const(0x16) [] -> [v6]
          results: [v6, %cs:arg, %os:arg]
        }
    } -> [v7, %cs, %os]
    n8 = WriteToField(offset=0, W1) [v7, %os:n4] -> [%os]
    results: [%cs:n4, %os:n8]
  }
}
"#, &[], true);
    assert_eq!(after, 11u8, "optimized output mismatch against expected");
    assert_eq!(after, before, "optimized and baseline outputs diverged");
}

