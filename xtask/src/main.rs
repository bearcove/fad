use std::fmt::Write as _;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Clone, Copy)]
enum BenchMode {
    Default,
    Ser,
    Ir,
    SerIr,
}

struct Case {
    name: &'static str,
    ty: &'static str,
    value: &'static str,
    mode: BenchMode,
    json_test: bool,
    postcard_test: bool,
    postcard_ir_test: bool,
}

const TYPES_RS: &str = r#"
#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize, Facet)]
struct Friend {
    age: u32,
    name: String,
}

#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize, Facet)]
struct Address {
    city: String,
    zip: u32,
}

#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize, Facet)]
struct Person {
    name: String,
    age: u32,
    address: Address,
}

#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize, Facet)]
struct Inner {
    x: u32,
}

#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize, Facet)]
struct Middle {
    inner: Inner,
    y: u32,
}

#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize, Facet)]
struct Outer {
    middle: Middle,
    z: u32,
}

#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize, Facet)]
struct AllIntegers {
    a_u8: u8,
    a_u16: u16,
    a_u32: u32,
    a_u64: u64,
    a_i8: i8,
    a_i16: i16,
    a_i32: i32,
    a_i64: i64,
}

#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize, Facet)]
struct BoolField {
    value: bool,
}

#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize, Facet)]
struct ScalarVec {
    values: Vec<u32>,
}

type Pair = (u32, String);
"#;

const CASES: &[Case] = &[
    Case {
        name: "flat_struct",
        ty: "Friend",
        value: r#"Friend { age: 42, name: "Alice".into() }"#,
        mode: BenchMode::SerIr,
        json_test: true,
        postcard_test: true,
        postcard_ir_test: true,
    },
    Case {
        name: "nested_struct",
        ty: "Person",
        value: r#"Person { name: "Alice".into(), age: 30, address: Address { city: "Portland".into(), zip: 97201 } }"#,
        mode: BenchMode::Ser,
        json_test: true,
        postcard_test: true,
        postcard_ir_test: false,
    },
    Case {
        name: "deep_struct",
        ty: "Outer",
        value: r#"Outer { middle: Middle { inner: Inner { x: 1 }, y: 2 }, z: 3 }"#,
        mode: BenchMode::SerIr,
        json_test: true,
        postcard_test: true,
        postcard_ir_test: true,
    },
    Case {
        name: "all_integers",
        ty: "AllIntegers",
        value: r#"AllIntegers { a_u8: 255, a_u16: 65535, a_u32: 1_000_000, a_u64: 1_000_000_000_000, a_i8: -128, a_i16: -32768, a_i32: -1_000_000, a_i64: -1_000_000_000_000 }"#,
        mode: BenchMode::Ser,
        json_test: true,
        postcard_test: true,
        postcard_ir_test: false,
    },
    Case {
        name: "bool_field",
        ty: "BoolField",
        value: r#"BoolField { value: true }"#,
        mode: BenchMode::Ser,
        json_test: true,
        postcard_test: true,
        postcard_ir_test: false,
    },
    Case {
        name: "tuple_pair",
        ty: "Pair",
        value: r#"(42u32, "Alice".to_string())"#,
        mode: BenchMode::Default,
        json_test: true,
        postcard_test: true,
        postcard_ir_test: false,
    },
    Case {
        name: "vec_scalar_small",
        ty: "ScalarVec",
        value: r#"ScalarVec { values: (0..16).map(|i| i as u32).collect() }"#,
        mode: BenchMode::Ir,
        json_test: true,
        postcard_test: true,
        postcard_ir_test: true,
    },
    Case {
        name: "vec_scalar_large",
        ty: "ScalarVec",
        value: r#"ScalarVec { values: (0..2048).map(|i| i as u32).collect() }"#,
        mode: BenchMode::Ir,
        json_test: true,
        postcard_test: true,
        postcard_ir_test: true,
    },
];

fn main() {
    let mut args = std::env::args();
    let _bin = args.next();
    match args.next().as_deref() {
        Some("generate-synthetic") => generate_synthetic(),
        _ => {
            eprintln!("usage: cargo run --manifest-path xtask/Cargo.toml -- generate-synthetic");
            std::process::exit(2);
        }
    }
}

fn generate_synthetic() {
    let root = workspace_root();
    let bench_path = root.join("benches/synthetic.rs");
    let test_path = root.join("tests/generated_synthetic.rs");
    write_file(&bench_path, &render_bench_file());
    write_file(&test_path, &render_test_file());
    println!(
        "generated:\n- {}\n- {}",
        bench_path.display(),
        test_path.display()
    );
}

fn render_bench_file() -> String {
    let mut out = String::new();
    out.push_str("// @generated by xtask generate-synthetic. Do not edit manually.\n");
    out.push_str("#[path = \"harness.rs\"]\nmod harness;\n\n");
    out.push_str("#[macro_use]\n#[path = \"common/bench_macros.rs\"]\nmod bench_macros;\n\n");
    out.push_str("use facet::Facet;\nuse std::hint::black_box;\nuse std::sync::LazyLock;\n\n");
    out.push_str(TYPES_RS.trim());
    out.push_str("\n\nfn main() {\n");
    out.push_str("    let mut v: Vec<harness::Bench> = Vec::new();\n\n");
    for case in CASES {
        write!(
            out,
            "    bench!(v, {}, {}, {}",
            case.name, case.ty, case.value
        )
        .unwrap();
        match case.mode {
            BenchMode::Default => {}
            BenchMode::Ser => out.push_str(", +ser"),
            BenchMode::Ir => out.push_str(", +ir"),
            BenchMode::SerIr => out.push_str(", +ser, +ir"),
        }
        out.push_str(");\n");
    }
    out.push_str("\n    harness::run_benchmarks(v);\n}\n");
    out
}

fn render_test_file() -> String {
    let mut out = String::new();
    out.push_str("// @generated by xtask generate-synthetic. Do not edit manually.\n");
    out.push_str("use facet::Facet;\n\n");
    out.push_str(TYPES_RS.trim());
    out.push_str("\n\n");

    out.push_str("fn assert_json_case<T>(value: T)\n");
    out.push_str("where\n");
    out.push_str("    for<'input> T: Facet<'input> + serde::Serialize + serde::de::DeserializeOwned + PartialEq + std::fmt::Debug,\n");
    out.push_str("{\n");
    out.push_str("    let encoded = serde_json::to_string(&value).unwrap();\n");
    out.push_str("    let expected: T = serde_json::from_str(&encoded).unwrap();\n");
    out.push_str("    let decoder = kajit::compile_decoder_legacy(T::SHAPE, &kajit::json::KajitJson);\n");
    out.push_str("    let got: T = kajit::from_str(&decoder, &encoded).unwrap();\n");
    out.push_str("    assert_eq!(got, expected);\n");
    out.push_str("}\n\n");

    out.push_str("fn assert_postcard_case<T>(value: T, with_ir: bool)\n");
    out.push_str("where\n");
    out.push_str("    for<'input> T: Facet<'input> + serde::Serialize + serde::de::DeserializeOwned + PartialEq + std::fmt::Debug,\n");
    out.push_str("{\n");
    out.push_str("    let encoded = postcard::to_allocvec(&value).unwrap();\n");
    out.push_str("    let expected: T = postcard::from_bytes(&encoded).unwrap();\n");
    out.push_str("    let legacy = kajit::compile_decoder_legacy(T::SHAPE, &kajit::postcard::KajitPostcard);\n");
    out.push_str("    let legacy_out: T = kajit::deserialize(&legacy, &encoded).unwrap();\n");
    out.push_str("    assert_eq!(legacy_out, expected);\n");
    out.push_str("    if with_ir {\n");
    out.push_str("        let ir = kajit::compile_decoder_via_ir(T::SHAPE, &kajit::postcard::KajitPostcard);\n");
    out.push_str("        let ir_out: T = kajit::deserialize(&ir, &encoded).unwrap();\n");
    out.push_str("        assert_eq!(ir_out, expected);\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    for case in CASES {
        if case.json_test {
            write!(
                out,
                "#[test]\nfn generated_json_{}() {{\n    let value: {} = {};\n    assert_json_case(value);\n}}\n\n",
                case.name, case.ty, case.value
            )
            .unwrap();
        }
        if case.postcard_test {
            write!(
                out,
                "#[test]\nfn generated_postcard_{}() {{\n    let value: {} = {};\n    assert_postcard_case(value, {});\n}}\n\n",
                case.name,
                case.ty,
                case.value,
                if case.postcard_ir_test { "true" } else { "false" }
            )
            .unwrap();
        }
    }

    out
}

fn workspace_root() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("xtask should live in workspace/xtask")
        .to_path_buf()
}

fn write_file(path: &Path, content: &str) {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).expect("create parent directory");
    }
    fs::write(path, content).expect("write generated file");
}
