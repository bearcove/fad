use std::fmt::Write as _;
use std::fs;
use std::path::{Path, PathBuf};

use crate::cases::{CASES, types_rs};
use crate::ir_behavior_cases::IR_BEHAVIOR_CASES;
use crate::ir_opt_cases::IR_OPT_CASES;
use crate::ir_postreg_cases::IR_POSTREG_CASES;

mod cases;
mod ir_behavior_cases;
mod ir_opt_cases;
mod ir_postreg_cases;

struct Case {
    name: &'static str,
    ty: &'static str,
    value: &'static str,
}

struct IrOptCase {
    name: &'static str,
    ir: &'static str,
    must_not_contain_after: &'static [&'static str],
    must_contain_after: &'static [&'static str],
    input: &'static [u8],
}

struct IrPostRegCase {
    name: &'static str,
    ir: &'static str,
    must_contain_linear: &'static [&'static str],
    max_total_edits: usize,
    input: &'static [u8],
    expected: u8,
}

struct BehaviorVector {
    input: &'static [u8],
    expected: u8,
}

struct IrBehaviorCase {
    name: &'static str,
    ir: &'static str,
    vectors: &'static [BehaviorVector],
}

fn main() {
    let mut args = std::env::args();
    let _bin = args.next();
    match args.next().as_deref() {
        Some("gen") => {
            generate_synthetic();
            generate_ir_behavior_corpus();
            generate_ir_opt_corpus();
            generate_ir_postreg_corpus();
        }
        _ => {
            eprintln!(
                "usage: cargo run --manifest-path xtask/Cargo.toml -- <generate-synthetic|generate-ir-opt-corpus|generate-ir-postreg-corpus|generate-ir-behavior-corpus>"
            );
            std::process::exit(2);
        }
    }
}

fn benches_prefix() -> PathBuf {
    workspace_root().join("kajit").join("benches")
}

fn tests_prefix() -> PathBuf {
    workspace_root().join("kajit").join("tests")
}

fn generate_synthetic() {
    let bench_path = benches_prefix().join("synthetic.rs");
    let test_path = tests_prefix().join("generated_synthetic.rs");
    write_file(&bench_path, &render_bench_file());
    write_file(&test_path, &render_test_file());
    println!(
        "generated:\n- {}\n- {}",
        bench_path.display(),
        test_path.display()
    );
}

fn generate_ir_opt_corpus() {
    let test_path = tests_prefix().join("generated_ir_opt_corpus.rs");
    write_file(&test_path, &render_ir_opt_test_file());
    println!("generated:\n- {}", test_path.display());
}

fn generate_ir_postreg_corpus() {
    let test_path = tests_prefix().join("generated_ir_postreg_corpus.rs");
    write_file(&test_path, &render_ir_postreg_test_file());
    println!("generated:\n- {}", test_path.display());
}

fn generate_ir_behavior_corpus() {
    let test_path = tests_prefix().join("generated_ir_behavior_corpus.rs");
    write_file(&test_path, &render_ir_behavior_test_file());
    println!("generated:\n- {}", test_path.display());
}

fn types_rs_pretty() -> String {
    let file: syn::File =
        syn::parse2(types_rs()).expect("types_rs quote output should parse as a Rust file");
    prettyplease::unparse(&file)
}

fn render_bench_file() -> String {
    let mut out = String::new();
    out.push_str("// @generated by xtask generate-synthetic. Do not edit manually.\n");
    out.push_str("#[path = \"harness.rs\"]\nmod harness;\n\n");
    out.push_str("#[macro_use]\n#[path = \"common/bench_macros.rs\"]\nmod bench_macros;\n\n");
    out.push_str("use facet::Facet;\nuse std::hint::black_box;\nuse std::sync::LazyLock;\n\n");
    out.push_str(types_rs_pretty().trim());
    out.push_str("\n\nfn main() {\n");
    out.push_str("    let mut v: Vec<harness::Bench> = Vec::new();\n\n");
    for case in CASES {
        write!(
            out,
            "    bench!(v, {}, {}, {}, +ser, +ir);\n",
            case.name, case.ty, case.value
        )
        .unwrap();
    }
    out.push_str("\n    harness::run_benchmarks(v);\n}\n");
    out
}

fn render_ir_behavior_test_file() -> String {
    let mut out = String::new();
    out.push_str("// @generated by xtask generate-ir-behavior-corpus. Do not edit manually.\n");
    out.push_str("use facet::Facet;\n\n");
    out.push_str("fn parse_case(ir: &str) -> kajit::ir::IrFunc {\n");
    out.push_str("    let registry = kajit::ir::IntrinsicRegistry::empty();\n");
    out.push_str("    kajit::ir_parse::parse_ir(ir, <u8 as Facet>::SHAPE, &registry)\n");
    out.push_str("        .expect(\"text IR should parse\")\n");
    out.push_str("}\n\n");
    out.push_str("fn run_exec(ir: &str, input: &[u8], with_passes: bool) -> u8 {\n");
    out.push_str("    let mut func = parse_case(ir);\n");
    out.push_str("    if with_passes {\n");
    out.push_str("        kajit::ir_passes::run_default_passes(&mut func);\n");
    out.push_str("    }\n");
    out.push_str("    let linear = kajit::linearize::linearize(&mut func);\n");
    out.push_str("    let dec = kajit::compile_decoder_linear_ir(&linear, false);\n");
    out.push_str("    kajit::deserialize::<u8>(&dec, input).expect(\"decoder should execute\")\n");
    out.push_str("}\n\n");

    for case in IR_BEHAVIOR_CASES {
        let test_name = format!("ir_behavior_{}", case.name);
        write!(out, "#[test]\nfn {test_name}() {{\n", test_name = test_name).unwrap();
        out.push_str("    let ir = r#\"");
        out.push_str(case.ir);
        out.push_str("\"#;\n");
        for vec in case.vectors {
            out.push_str("    {\n");
            out.push_str("        let input: &[u8] = &[");
            for (idx, b) in vec.input.iter().enumerate() {
                if idx > 0 {
                    out.push_str(", ");
                }
                out.push_str(&b.to_string());
            }
            out.push_str("];\n");
            out.push_str(&format!("        let expected: u8 = {};\n", vec.expected));
            out.push_str("        let baseline = run_exec(ir, input, false);\n");
            out.push_str("        let optimized = run_exec(ir, input, true);\n");
            out.push_str("        assert_eq!(baseline, expected, \"baseline output mismatch\");\n");
            out.push_str(
                "        assert_eq!(optimized, expected, \"optimized output mismatch\");\n",
            );
            out.push_str(
                "        assert_eq!(optimized, baseline, \"optimized and baseline outputs diverged\");\n",
            );
            out.push_str("    }\n");
        }
        out.push_str("}\n\n");
    }

    out
}

fn render_ir_postreg_test_file() -> String {
    let mut out = String::new();
    out.push_str("// @generated by xtask generate-ir-postreg-corpus. Do not edit manually.\n");
    out.push_str("use facet::Facet;\n\n");
    out.push_str("fn parse_case(ir: &str) -> kajit::ir::IrFunc {\n");
    out.push_str("    let registry = kajit::ir::IntrinsicRegistry::empty();\n");
    out.push_str("    kajit::ir_parse::parse_ir(ir, <u8 as Facet>::SHAPE, &registry)\n");
    out.push_str("        .expect(\"text IR should parse\")\n");
    out.push_str("}\n\n");
    out.push_str("fn run_exec(ir: &str, input: &[u8], with_passes: bool) -> u8 {\n");
    out.push_str("    let mut func = parse_case(ir);\n");
    out.push_str("    if with_passes {\n");
    out.push_str("        kajit::ir_passes::run_default_passes(&mut func);\n");
    out.push_str("    }\n");
    out.push_str("    let linear = kajit::linearize::linearize(&mut func);\n");
    out.push_str("    let dec = kajit::compile_decoder_linear_ir(&linear, false);\n");
    out.push_str("    kajit::deserialize::<u8>(&dec, input).expect(\"decoder should execute\")\n");
    out.push_str("}\n\n");
    out.push_str("fn postreg_artifacts(ir: &str) -> (String, String, usize) {\n");
    out.push_str("    let mut func = parse_case(ir);\n");
    out.push_str("    kajit::ir_passes::run_default_passes(&mut func);\n");
    out.push_str("    let linear = kajit::linearize::linearize(&mut func);\n");
    out.push_str("    let linear_text = format!(\"{linear}\");\n");
    out.push_str("    let ra = kajit::regalloc_mir::lower_linear_ir(&linear);\n");
    out.push_str("    let ra_text = format!(\"{ra}\");\n");
    out.push_str("    let alloc = kajit::regalloc_engine::allocate_program(&ra)\n");
    out.push_str("        .expect(\"regalloc should allocate post-reg corpus case\");\n");
    out.push_str("    let edits: usize = alloc.functions.iter().map(|f| f.edits.len()).sum();\n");
    out.push_str("    (linear_text, ra_text, edits)\n");
    out.push_str("}\n\n");

    for case in IR_POSTREG_CASES {
        let snap_test = format!("ir_postreg_snapshot_{}", case.name);
        let assert_test = format!("ir_postreg_asserts_{}", case.name);
        let exec_test = format!("ir_postreg_exec_{}", case.name);

        write!(
            out,
            "#[test]\nfn {snap_test}() {{\n    let (linear, ra, edits) = postreg_artifacts(r#\"{ir}\"#);\n    insta::assert_snapshot!(\"generated_ir_postreg_linear_{name}\", linear);\n    insta::assert_snapshot!(\"generated_ir_postreg_ra_{name}\", ra);\n    insta::assert_snapshot!(\"generated_ir_postreg_edits_{name}\", format!(\"{{edits}}\"));\n}}\n\n",
            snap_test = snap_test,
            ir = case.ir,
            name = case.name
        )
        .unwrap();

        write!(
            out,
            "#[test]\nfn {assert_test}() {{\n    let (linear, _ra, edits) = postreg_artifacts(r#\"{ir}\"#);\n    assert!(edits <= {max_edits}, \"expected edit budget <= {max_edits}, got {{edits}}\");\n",
            assert_test = assert_test,
            ir = case.ir,
            max_edits = case.max_total_edits
        )
        .unwrap();
        for needle in case.must_contain_linear {
            writeln!(
                out,
                "    assert!(linear.contains(r#\"{needle}\"#), \"expected linear artifact to contain: {{}}\", r#\"{needle}\"#);",
                needle = needle
            )
            .unwrap();
        }
        out.push_str("}\n\n");

        out.push_str(&format!(
            "#[test]\nfn {exec_test}() {{\n",
            exec_test = exec_test
        ));
        out.push_str("    let before = run_exec(r#\"");
        out.push_str(case.ir);
        out.push_str("\"#, &[");
        for (idx, b) in case.input.iter().enumerate() {
            if idx > 0 {
                out.push_str(", ");
            }
            out.push_str(&b.to_string());
        }
        out.push_str("], false);\n");
        out.push_str("    let after = run_exec(r#\"");
        out.push_str(case.ir);
        out.push_str("\"#, &[");
        for (idx, b) in case.input.iter().enumerate() {
            if idx > 0 {
                out.push_str(", ");
            }
            out.push_str(&b.to_string());
        }
        out.push_str("], true);\n");
        out.push_str(&format!(
            "    assert_eq!(after, {}u8, \"optimized output mismatch against expected\");\n",
            case.expected
        ));
        out.push_str(
            "    assert_eq!(after, before, \"optimized and baseline outputs diverged\");\n",
        );
        out.push_str("}\n\n");
    }

    out
}

fn render_ir_opt_test_file() -> String {
    let mut out = String::new();
    out.push_str("// @generated by xtask generate-ir-opt-corpus. Do not edit manually.\n");
    out.push_str("use facet::Facet;\n\n");
    out.push_str("fn parse_case(ir: &str) -> kajit::ir::IrFunc {\n");
    out.push_str("    let registry = kajit::ir::IntrinsicRegistry::empty();\n");
    out.push_str("    kajit::ir_parse::parse_ir(ir, <u8 as Facet>::SHAPE, &registry)\n");
    out.push_str("        .expect(\"text IR should parse\")\n");
    out.push_str("}\n\n");
    out.push_str("fn run_pass(ir: &str) -> (String, String) {\n");
    out.push_str("    let mut func = parse_case(ir);\n");
    out.push_str("    let before = format!(\"{func}\");\n");
    out.push_str("    kajit::ir_passes::run_default_passes(&mut func);\n");
    out.push_str("    let after = format!(\"{func}\");\n");
    out.push_str("    (before, after)\n");
    out.push_str("}\n\n");
    out.push_str("fn run_exec(ir: &str, input: &[u8]) -> u8 {\n");
    out.push_str("    let mut func = parse_case(ir);\n");
    out.push_str("    let linear = kajit::linearize::linearize(&mut func);\n");
    out.push_str("    let dec = kajit::compile_decoder_linear_ir(&linear, false);\n");
    out.push_str("    kajit::deserialize::<u8>(&dec, input).expect(\"decoder should execute\")\n");
    out.push_str("}\n\n");

    for case in IR_OPT_CASES {
        let test_name_snapshot = format!("ir_opt_snapshot_{}", case.name);
        let test_name_asserts = format!("ir_opt_asserts_{}", case.name);
        let test_name_exec = format!("ir_opt_exec_{}", case.name);

        write!(
            out,
            "#[test]\nfn {test_name_snapshot}() {{\n    let (before, after) = run_pass(r#\"{ir}\"#);\n    insta::assert_snapshot!(\"generated_ir_opt_before_{name}\", before);\n    insta::assert_snapshot!(\"generated_ir_opt_after_{name}\", after);\n}}\n\n",
            test_name_snapshot = test_name_snapshot,
            ir = case.ir,
            name = case.name
        )
        .unwrap();

        write!(
            out,
            "#[test]\nfn {test_name_asserts}() {{\n    let (_before, after) = run_pass(r#\"{ir}\"#);\n",
            test_name_asserts = test_name_asserts,
            ir = case.ir
        )
        .unwrap();
        for needle in case.must_not_contain_after {
            writeln!(
                out,
                "    assert!(!after.contains(r#\"{needle}\"#), \"expected to hoist/remove: {{}}\", r#\"{needle}\"#);",
                needle = needle
            )
            .unwrap();
        }
        for needle in case.must_contain_after {
            writeln!(
                out,
                "    assert!(after.contains(r#\"{needle}\"#), \"expected to keep/preserve: {{}}\", r#\"{needle}\"#);",
                needle = needle
            )
            .unwrap();
        }
        out.push_str("}\n\n");

        out.push_str(&format!(
            "#[test]\nfn {test_name_exec}() {{\n",
            test_name_exec = test_name_exec
        ));
        out.push_str("    let before_out = run_exec(r#\"");
        out.push_str(case.ir);
        out.push_str("\"#, &[");
        for (idx, b) in case.input.iter().enumerate() {
            if idx > 0 {
                out.push_str(", ");
            }
            out.push_str(&b.to_string());
        }
        out.push_str("]);\n");
        out.push_str("    let mut optimized = parse_case(r#\"");
        out.push_str(case.ir);
        out.push_str("\"#);\n");
        out.push_str("    kajit::ir_passes::run_default_passes(&mut optimized);\n");
        out.push_str("    let linear = kajit::linearize::linearize(&mut optimized);\n");
        out.push_str("    let dec = kajit::compile_decoder_linear_ir(&linear, false);\n");
        out.push_str("    let after_out = kajit::deserialize::<u8>(&dec, &[");
        for (idx, b) in case.input.iter().enumerate() {
            if idx > 0 {
                out.push_str(", ");
            }
            out.push_str(&b.to_string());
        }
        out.push_str("]).expect(\"optimized decoder should execute\");\n");
        out.push_str("    assert_eq!(after_out, before_out);\n");
        out.push_str("}\n\n");
    }

    out
}

fn render_test_file() -> String {
    let mut out = String::new();
    out.push_str("// @generated by xtask generate-synthetic. Do not edit manually.\n");
    out.push_str("use facet::Facet;\n\n");
    out.push_str(types_rs_pretty().trim());
    out.push_str("\n\n");

    out.push_str("fn assert_json_case<T>(value: T)\n");
    out.push_str("where\n");
    out.push_str("    for<'input> T: Facet<'input> + serde::Serialize + serde::de::DeserializeOwned + PartialEq + std::fmt::Debug,\n");
    out.push_str("{\n");
    out.push_str("    let encoded = serde_json::to_string(&value).unwrap();\n");
    out.push_str("    let expected: T = serde_json::from_str(&encoded).unwrap();\n");
    out.push_str(
        "    let decoder = kajit::compile_decoder_legacy(T::SHAPE, &kajit::json::KajitJson);\n",
    );
    out.push_str("    let got: T = kajit::from_str(&decoder, &encoded).unwrap();\n");
    out.push_str("    assert_eq!(got, expected);\n");
    out.push_str("}\n\n");

    out.push_str("fn assert_postcard_case<T>(value: T, with_ir: bool)\n");
    out.push_str("where\n");
    out.push_str("    for<'input> T: Facet<'input> + serde::Serialize + serde::de::DeserializeOwned + PartialEq + std::fmt::Debug,\n");
    out.push_str("{\n");
    out.push_str("    let encoded = postcard::to_allocvec(&value).unwrap();\n");
    out.push_str("    let expected: T = postcard::from_bytes(&encoded).unwrap();\n");
    out.push_str("    let legacy = kajit::compile_decoder_legacy(T::SHAPE, &kajit::postcard::KajitPostcard);\n");
    out.push_str("    let legacy_out: T = kajit::deserialize(&legacy, &encoded).unwrap();\n");
    out.push_str("    assert_eq!(legacy_out, expected);\n");
    out.push_str("    if with_ir {\n");
    out.push_str("        let ir = kajit::compile_decoder_via_ir(T::SHAPE, &kajit::postcard::KajitPostcard);\n");
    out.push_str("        let ir_out: T = kajit::deserialize(&ir, &encoded).unwrap();\n");
    out.push_str("        assert_eq!(ir_out, expected);\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    out.push_str("fn assert_ir_ra_snapshots(\n");
    out.push_str("    case: &str,\n");
    out.push_str("    format_label: &str,\n");
    out.push_str("    shape: &'static facet::Shape,\n");
    out.push_str("    decoder: &dyn kajit::format::IrDecoder,\n");
    out.push_str(") {\n");
    out.push_str("    let (ir_text, ra_text) = kajit::debug_ir_and_ra_mir_text(shape, decoder);\n");
    out.push_str("    insta::assert_snapshot!(\n");
    out.push_str("        format!(\n");
    out.push_str("            \"generated_rvsdg_{}_{}_{}\",\n");
    out.push_str("            format_label,\n");
    out.push_str("            case,\n");
    out.push_str("            std::env::consts::ARCH\n");
    out.push_str("        ),\n");
    out.push_str("        ir_text\n");
    out.push_str("    );\n");
    out.push_str("    insta::assert_snapshot!(\n");
    out.push_str("        format!(\n");
    out.push_str("            \"generated_ra_mir_{}_{}_{}\",\n");
    out.push_str("            format_label,\n");
    out.push_str("            case,\n");
    out.push_str("            std::env::consts::ARCH\n");
    out.push_str("        ),\n");
    out.push_str("        ra_text\n");
    out.push_str("    );\n");
    out.push_str("}\n\n");

    for case in CASES {
        write!(
            out,
            "#[test]\nfn generated_json_{}() {{\n    let value: {} = {};\n    assert_json_case(value);\n}}\n\n",
            case.name, case.ty, case.value
        )
        .unwrap();
        write!(
            out,
            "#[test]\nfn generated_postcard_{}() {{\n    let value: {} = {};\n    assert_postcard_case(value, true);\n    assert_ir_ra_snapshots(\"{}\", \"postcard\", <{}>::SHAPE, &kajit::postcard::KajitPostcard);\n}}\n\n",
            case.name,
            case.ty,
            case.value,
            case.name,
            case.ty
        )
        .unwrap();
    }

    out
}

fn workspace_root() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("xtask should live in workspace/xtask")
        .to_path_buf()
}

fn write_file(path: &Path, content: &str) {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).expect("create parent directory");
    }
    fs::write(path, content).expect("write generated file");
}
