### Summary

This issue tracks potential improvements to the IR optimization passes for better correctness, maintainability, and extensibility. Specific notes and suggestions are provided for each pass, as well as general improvements to the data model.

---

### Pass-by-pass notes

#### Bounds-check coalescing

What it’s doing is sane: walk the StateCursor chain, track bytes consumed via cursor-advancing ops, and fold a later bounds-check into an earlier one by increasing the count and deleting the later check. Opportunities include:

- **Correctness "by design"**: Define a cursor-chain invariant. Current reliance is on an implicit property: “state cursor forms a linear token chain through the scheduled node list.” Make it a verifier rule:
  - Each node has at most one `StateCursor` in/out.
  - If it has `StateCursor` out, it must have `StateCursor` in (except region args).
  - Region node order is a valid schedule for the token chain.
- **Generalize the chain-step definition**: Instead of whitelisting specific ops (e.g., `ReadBytes`, `AdvanceCursor`), adopt a model where each op declares `cursor_advance: Option<u32>` and "preserves cursor chain."
- **Algorithmic cleanup**: Transition from the current approach of repeating outer-loop scans to a single linear walk per region, folding maximal prefixes.

---

#### Theta loop-invariant hoisting

The intent is great: hoist a "setup tree" (consts/arithmetic/etc.) out of the theta body to avoid polluting hot state with loop-carried dependencies. Present issues include:

- **Order-dependence bug/incompleteness**: Iterate to a fixpoint for hoistable nodes or apply a topological sort on the candidate DAG.
- **Scoping/cross-region references**: Current approach replaces uses with new node outputs directly. Consider adopting a clearer model:
  - Hoist nodes in parent region.
  - Add them as extra inputs to `Theta`.
  - Replace body references with `RegionArgs` internally.

---

#### Inline apply

While the inlining logic and size heuristics appear reasonable, the following concerns arise:

- **Scheduled/topological order reliance**: Node cloning assumes that defs precede uses within region order. To ensure correctness, either:
  - Require `region order` to be topological (recommended).
  - Implement cloning in two phases: pre-create node IDs, then fill inputs.
  
---

### Additional Improvements

#### Whole-program scans for rewrites
Currently, `replace_output_use()` scans all nodes and region results, dramatically increasing runtime complexity. Instead,:

- Maintain a use-list per `OutputRef` to reduce replacement runtime.
- Enforce correctness by asserting no dangling use-sites, facilitating easier DCE and copy propagation.

#### Missing "glue" passes
To ensure other optimization passes work effectively:

- **Copy-propagation/trivial node folding**: Clean move-style nodes.
- **Dead code elimination (DCE)**: Clean leftover dead computations post-optimizations.

---

### "Correctness by Design" Checklist

Adding verifiers for these will simplify optimizations:

1. Region node list is a valid schedule.
2. Each state token kind forms a well-typed chain.
3. Region scoping follows explicit rules.
4. Every `OutputRef` has accurate use-sites.

If one refactor is prioritized, **use-lists with a verifier pass** would offer the highest ROI.